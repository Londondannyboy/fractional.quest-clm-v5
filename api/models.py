"""Response models for Fractional Quest career advisor."""

from pydantic import BaseModel, Field, field_validator
from typing import Optional
from enum import Enum


class JobResult(BaseModel):
    """A retrieved job from the database."""

    id: str
    title: str
    company_name: str
    location: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    executive_title: Optional[str] = None
    role_category: Optional[str] = None
    industry: Optional[str] = None
    is_remote: Optional[bool] = None
    estimated_hourly_rate_min: Optional[int] = None
    estimated_hourly_rate_max: Optional[int] = None
    hours_per_week: Optional[str] = None
    description_snippet: Optional[str] = None
    appeal_summary: Optional[str] = None
    posted_date: Optional[str] = None
    url: Optional[str] = None
    slug: Optional[str] = None


class JobSearchResults(BaseModel):
    """Results from job search."""

    jobs: list[JobResult]
    query: str
    total_count: int = 0


class MarketStats(BaseModel):
    """Job market statistics."""

    total_jobs: int
    by_executive_title: list[dict] = Field(default_factory=list)
    by_role_category: list[dict] = Field(default_factory=list)
    by_city: list[dict] = Field(default_factory=list)
    remote_jobs: int = 0
    on_site_jobs: int = 0
    avg_hourly_rate_min: Optional[float] = None
    avg_hourly_rate_max: Optional[float] = None


class SalaryBenchmark(BaseModel):
    """Salary benchmark for a role/location combination."""

    title: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    avg_hourly_min: Optional[float] = None
    avg_hourly_max: Optional[float] = None
    hourly_range: Optional[str] = None
    job_count: int = 0


class DeclinedResponse(BaseModel):
    """Response when we cannot answer from available sources."""

    response_text: str
    reason: str

    @field_validator('response_text')
    @classmethod
    def must_indicate_limitation(cls, v: str) -> str:
        """Ensure the response indicates we're declining to answer."""
        decline_phrases = [
            "don't have", "don't see", "can't find", "not sure",
            "no listings", "no information", "couldn't find", "no current"
        ]
        if not any(phrase in v.lower() for phrase in decline_phrases):
            raise ValueError(
                "Declined response must indicate limitation to user"
            )
        return v


# =============================================================================
# Agent Models - For multi-step reasoning and enrichment
# =============================================================================


class RoleType(str, Enum):
    """Types of executive roles."""
    CFO = "CFO"
    CMO = "CMO"
    CTO = "CTO"
    COO = "COO"
    CHRO = "CHRO"
    CRO = "CRO"
    CISO = "CISO"
    OTHER = "other"


class SkillCategory(str, Enum):
    """Categories of executive skills."""
    FINANCE = "finance"
    MARKETING = "marketing"
    TECHNOLOGY = "technology"
    OPERATIONS = "operations"
    HR = "hr"
    SALES = "sales"
    SECURITY = "security"
    STRATEGY = "strategy"


class ExtractedJobInfo(BaseModel):
    """Key information extracted from a job listing."""
    company: str
    role_type: Optional[RoleType] = None
    key_skills: list[str] = Field(default_factory=list)
    location: Optional[str] = None
    rate_range: Optional[str] = None
    unique_appeal: Optional[str] = None  # What makes this role special


class MarketTrend(BaseModel):
    """A trend identified in the job market."""
    trend: str
    evidence: str  # What data supports this
    implication: str  # What it means for job seekers


class SuggestedTopic(BaseModel):
    """A proactive follow-up topic suggestion."""
    topic: str
    reason: str  # Why this is relevant to the user
    teaser: str  # One-sentence hook


class FastFQResponse(BaseModel):
    """Minimal response for fast path - no enrichment.

    Used for initial response within 2 seconds.
    """
    response_text: str
    job_titles: list[str] = Field(default_factory=list)

    @field_validator('response_text')
    @classmethod
    def response_not_empty(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("Response cannot be empty")
        return v.strip()


class EnrichedFQResponse(BaseModel):
    """Extended response with market insights and suggestions.

    Generated by background enrichment process after initial response.
    """
    response_text: str
    job_titles: list[str] = Field(default_factory=list)

    # Enrichment fields
    jobs_mentioned: list[ExtractedJobInfo] = Field(default_factory=list)
    market_trends: list[MarketTrend] = Field(default_factory=list)
    suggested_topics: list[SuggestedTopic] = Field(default_factory=list)

    # Metadata
    enrichment_complete: bool = False
    total_jobs_available: int = 0

    def get_job_companies(self) -> list[str]:
        """Get list of company names mentioned."""
        return [j.company for j in self.jobs_mentioned]

    def get_top_suggestion(self) -> Optional[SuggestedTopic]:
        """Get the best follow-up suggestion."""
        return self.suggested_topics[0] if self.suggested_topics else None
